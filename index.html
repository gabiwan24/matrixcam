<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Tracker (Block Matching)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            background-color: #050505;
            color: #00ff41; 
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            image-rendering: pixelated; /* Knackige Pixel beim Hochskalieren */
        }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #004400; }
        
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            background: #00ff41;
            margin-top: -5px;
            border-radius: 50%;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #003300;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-black border-b border-green-900 p-3 flex justify-between items-center shrink-0 z-20">
        <div class="flex items-center gap-3">
            <i data-lucide="crosshair" class="text-green-500"></i>
            <h1 class="text-lg font-bold text-green-500 tracking-widest uppercase">Pixel<span class="text-white">Tracker</span></h1>
        </div>
        <div class="text-[10px] text-green-800 font-mono">
            BLOCK_MATCHING_ENGINE_V2.1_FULL
        </div>
    </header>

    <div class="flex-1 flex flex-col lg:flex-row overflow-hidden relative">
        
        <!-- Controls -->
        <aside class="w-full lg:w-72 bg-black/95 p-4 overflow-y-auto shrink-0 border-r border-green-900/50 z-10 backdrop-blur-sm text-xs">
            
            <div class="mb-6 p-3 border border-green-800 bg-green-900/10 font-mono shadow-[0_0_10px_rgba(0,255,0,0.05)]">
                <div class="flex justify-between mb-2 border-b border-green-800 pb-1">
                    <span>CPU_LOAD</span>
                    <span id="loadIndicator" class="text-green-500">LOW</span>
                </div>
                <div class="grid grid-cols-2 gap-1 text-green-700">
                    <div>FPS:</div> <div id="fpsCounter" class="text-right text-green-400">0</div>
                    <div>VECTORS:</div> <div id="vectorCount" class="text-right text-green-400">0</div>
                    <div>RES:</div> <div id="resDisplay" class="text-right text-green-400">--</div>
                </div>
            </div>

            <div class="space-y-6 font-mono">
                <div>
                    <h3 class="text-[10px] font-bold text-green-700 uppercase mb-2">[ DEVICE ]</h3>
                    <select id="cameraSelect" class="w-full bg-black border border-green-800 text-green-500 p-1 mb-2 outline-none hidden"></select>
                    <button id="btnToggle" class="w-full border border-green-600 text-green-500 hover:bg-green-600 hover:text-black font-bold py-2 px-2 transition-all uppercase flex items-center justify-center gap-2">
                        <i data-lucide="power" class="w-4 h-4"></i> <span>System Start</span>
                    </button>
                </div>

                <div>
                    <h3 class="text-[10px] font-bold text-green-700 uppercase mb-4">[ TRACKING_PARAMS ]</h3>
                    
                    <div class="mb-4">
                        <div class="flex justify-between text-green-600 mb-1">
                            <span>GRID_SIZE (Block Size)</span>
                            <span id="valGrid">24px</span>
                        </div>
                        <input type="range" id="gridSize" min="16" max="64" step="4" value="24" class="w-full">
                    </div>

                    <div class="mb-4">
                        <div class="flex justify-between text-green-600 mb-1">
                            <span>SEARCH_RADIUS (Range)</span>
                            <span id="valRadius">12px</span>
                        </div>
                        <input type="range" id="searchRadius" min="4" max="24" step="2" value="12" class="w-full">
                        <p class="text-[9px] text-green-900 mt-1">High radius = High CPU usage</p>
                    </div>

                    <div class="mb-4">
                        <div class="flex justify-between text-green-600 mb-1">
                            <span>THRESHOLD (Min Change)</span>
                            <span id="valThresh">10</span>
                        </div>
                        <input type="range" id="threshold" min="2" max="50" step="1" value="10" class="w-full">
                    </div>
                </div>

                <div>
                    <h3 class="text-[10px] font-bold text-green-700 uppercase mb-2">[ RENDER ]</h3>
                    <div class="flex gap-1 mb-3">
                        <button class="mode-btn flex-1 border border-green-900 text-green-800 py-1 hover:bg-green-900/30 data-[active=true]:border-green-500 data-[active=true]:text-green-400" data-mode="lines" data-active="true">LINE</button>
                        <button class="mode-btn flex-1 border border-green-900 text-green-800 py-1 hover:bg-green-900/30 data-[active=true]:border-green-500 data-[active=true]:text-green-400" data-mode="arrows" data-active="false">ARROW</button>
                        <button class="mode-btn flex-1 border border-green-900 text-green-800 py-1 hover:bg-green-900/30 data-[active=true]:border-green-500 data-[active=true]:text-green-400" data-mode="block" data-active="false">BOX</button>
                    </div>
                    
                    <div class="flex items-center gap-2 mb-2">
                        <input type="checkbox" id="showVideo" class="accent-green-500 bg-black border-green-800">
                        <label for="showVideo" class="text-green-600">VIDEO_OVERLAY</label>
                    </div>
                    <div class="flex items-center gap-2">
                         <input type="checkbox" id="trailEffect" class="accent-green-500 bg-black border-green-800" checked>
                        <label for="trailEffect" class="text-green-600">TRAILS</label>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Viewport -->
        <main class="flex-1 bg-black relative flex items-center justify-center overflow-hidden">
            <!-- Fullscreen Container -->
            <div class="relative w-full h-full bg-black flex items-center justify-center">
                <!-- Canvas scaled to fill via CSS -->
                <canvas id="outputCanvas" class="w-full h-full object-contain block"></canvas>
                
                <!-- Overlay HUD -->
                <div id="noSignal" class="absolute inset-0 flex flex-col items-center justify-center bg-black/90 z-20 pointer-events-none">
                    <i data-lucide="cpu" class="w-12 h-12 text-green-900 mb-2"></i>
                    <p class="text-green-800 font-mono text-xs animate-pulse">AWAITING_INPUT_STREAM</p>
                </div>
            </div>
            <video id="webcamVideo" class="hidden" autoplay playsinline muted></video>
        </main>
    </div>

    <script>
        // Init Icons safely
        const initIcons = () => {
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons();
            }
        };
        window.addEventListener('load', initIcons);

        // --- Config ---
        const config = {
            gridSize: 24,      // Size of the grid cells
            searchRadius: 12,  // How far to search for the pixel block
            threshold: 10,     // Minimum pixel difference to trigger search
            mode: 'lines',
            showVideo: false,
            trail: true,
            sampleStep: 2      // Optimization: Check only every Nth pixel during search
        };

        // --- State ---
        let stream = null;
        let isRunning = false;
        let animationId;
        
        // We use a separate logic: 
        // We need the PREVIOUS frame's full pixel data to compare against CURRENT frame
        let prevCtx = null;
        let workCanvas = null; 
        let workCtx = null;
        
        // --- DOM ---
        const video = document.getElementById('webcamVideo');
        const canvas = document.getElementById('outputCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no alpha
        
        const btnToggle = document.getElementById('btnToggle');
        const cameraSelect = document.getElementById('cameraSelect');
        const noSignal = document.getElementById('noSignal');
        const loadIndicator = document.getElementById('loadIndicator');
        const fpsDisplay = document.getElementById('fpsCounter');
        const vectorCountDisplay = document.getElementById('vectorCount');
        const resDisplay = document.getElementById('resDisplay');

        // --- Event Listeners ---
        const updateUIVal = (id, val, suffix='') => document.getElementById(id).innerText = val + suffix;

        document.getElementById('gridSize').addEventListener('input', (e) => {
            config.gridSize = parseInt(e.target.value);
            updateUIVal('valGrid', config.gridSize, 'px');
        });
        document.getElementById('searchRadius').addEventListener('input', (e) => {
            config.searchRadius = parseInt(e.target.value);
            updateUIVal('valRadius', config.searchRadius, 'px');
        });
        document.getElementById('threshold').addEventListener('input', (e) => {
            config.threshold = parseInt(e.target.value);
            updateUIVal('valThresh', config.threshold);
        });
        document.getElementById('showVideo').addEventListener('change', (e) => config.showVideo = e.target.checked);
        document.getElementById('trailEffect').addEventListener('change', (e) => config.trail = e.target.checked);

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => {
                    b.dataset.active = "false";
                    b.classList.remove('border-green-500');
                });
                btn.dataset.active = "true";
                btn.classList.add('border-green-500');
                config.mode = btn.dataset.mode;
            });
        });

        cameraSelect.addEventListener('change', () => { if (isRunning) startCamera(); });

        btnToggle.addEventListener('click', () => {
            if (isRunning) stopCamera();
            else startCamera();
        });

        // --- Camera System ---
        async function getDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(d => d.kind === 'videoinput');
                cameraSelect.innerHTML = '';
                videoDevices.forEach((d, i) => {
                    const opt = document.createElement('option');
                    opt.value = d.deviceId;
                    opt.text = d.label || `CAM_${i+1}`;
                    cameraSelect.appendChild(opt);
                });
                if (videoDevices.length > 0) cameraSelect.classList.remove('hidden');
            } catch(e) { console.error(e); }
        }

        async function startCamera() {
            stopCamera();
            
            // Low resolution is ESSENTIAL for Block Matching in JS
            // 320x240 is usually the sweet spot for realtime CPU analysis
            const constraints = {
                video: {
                    width: { ideal: 320 }, 
                    height: { ideal: 240 },
                    frameRate: { ideal: 30 },
                    deviceId: cameraSelect.value ? { exact: cameraSelect.value } : undefined
                }
            };

            try {
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                getDevices();

                video.onloadedmetadata = () => {
                    video.play();
                    
                    // Internal canvas logic matches LOW res video (e.g. 320x240)
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    resDisplay.innerText = `${canvas.width}x${canvas.height}`;

                    // Working buffer for previous frame
                    workCanvas = document.createElement('canvas');
                    workCanvas.width = canvas.width;
                    workCanvas.height = canvas.height;
                    workCtx = workCanvas.getContext('2d', { willReadFrequently: true });
                    
                    // Init logic
                    isRunning = true;
                    noSignal.classList.add('hidden');
                    
                    btnToggle.innerHTML = `<i data-lucide="square" class="w-4 h-4"></i> <span>STOP TRACKING</span>`;
                    btnToggle.classList.replace('border-green-600', 'border-red-600');
                    btnToggle.classList.replace('text-green-500', 'text-red-500');
                    btnToggle.classList.replace('hover:bg-green-600', 'hover:bg-red-600');
                    initIcons();

                    requestAnimationFrame(loop);
                };
            } catch (err) {
                alert("Error: " + err.message);
            }
        }

        function stopCamera() {
            isRunning = false;
            cancelAnimationFrame(animationId);
            if (stream) stream.getTracks().forEach(t => t.stop());
            
            noSignal.classList.remove('hidden');
            btnToggle.innerHTML = `<i data-lucide="power" class="w-4 h-4"></i> <span>SYSTEM START</span>`;
            btnToggle.classList.replace('border-red-600', 'border-green-600');
            btnToggle.classList.replace('text-red-500', 'text-green-500');
            btnToggle.classList.replace('hover:bg-red-600', 'hover:bg-green-600');
            initIcons();
            
            ctx.clearRect(0,0, canvas.width, canvas.height);
            resDisplay.innerText = "--";
        }

        // --- Tracking Core ---

        let lastTime = 0;
        let frameCount = 0;
        let lastFpsTime = 0;

        function loop(time) {
            if (!isRunning) return;

            // Stats
            frameCount++;
            if (time - lastFpsTime >= 1000) {
                const fps = frameCount;
                fpsDisplay.innerText = fps;
                
                // Load coloring
                if(fps < 15) loadIndicator.innerText = "CRITICAL"; 
                else if(fps < 25) loadIndicator.innerText = "HIGH";
                else loadIndicator.innerText = "OPTIMAL";
                
                loadIndicator.className = fps < 25 ? "text-red-500 animate-pulse" : "text-green-500";

                frameCount = 0;
                lastFpsTime = time;
            }

            processBlockMatching();
            animationId = requestAnimationFrame(loop);
        }

        function processBlockMatching() {
            const w = canvas.width;
            const h = canvas.height;
            
            // 1. Draw current video to main canvas (or fade)
            if (config.showVideo) {
                ctx.globalAlpha = 1.0;
                ctx.drawImage(video, 0, 0, w, h);
                ctx.fillStyle = 'rgba(0,0,0,0.6)'; // Darken to make green pop
                ctx.fillRect(0,0,w,h);
            } else {
                if (config.trail) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; // Trail fade
                    ctx.fillRect(0, 0, w, h);
                } else {
                    ctx.clearRect(0, 0, w, h);
                }
            }

            // 2. Get pixel data
            // Current Frame Data
            const currentCtx = workCtx; 
            currentCtx.drawImage(video, 0, 0); 
            const imgDataCurrent = currentCtx.getImageData(0, 0, w, h).data;
            
            // If we don't have a previous frame buffer, create it and skip this frame
            if (!prevCtx) {
                // Initialize "Previous Frame" buffer
                const pCanvas = document.createElement('canvas');
                pCanvas.width = w; pCanvas.height = h;
                prevCtx = pCanvas.getContext('2d', { willReadFrequently: true });
                prevCtx.drawImage(video, 0, 0);
                return;
            }

            const imgDataPrev = prevCtx.getImageData(0, 0, w, h).data;

            // 3. BLOCK MATCHING LOOP
            const grid = config.gridSize;
            const radius = config.searchRadius;
            const step = config.sampleStep; // Optimization: don't check every pixel
            const threshold = config.threshold; // Noise gate
            
            let vectors = 0;
            
            ctx.strokeStyle = '#00ff41';
            ctx.fillStyle = '#00ff41';
            ctx.lineWidth = 1;

            // Iterate through the grid
            for (let y = grid; y < h - grid; y += grid) {
                for (let x = grid; x < w - grid; x += grid) {
                    
                    const centerIdx = (y * w + x) * 4;
                    
                    // Simple check: Has the center pixel changed enough to warrant a search?
                    // This is an optimization to avoid searching stationary blocks (walls)
                    const diffR = Math.abs(imgDataCurrent[centerIdx] - imgDataPrev[centerIdx]);
                    const diffG = Math.abs(imgDataCurrent[centerIdx+1] - imgDataPrev[centerIdx+1]);
                    
                    if ((diffR + diffG) / 2 < threshold) {
                        continue; // Skip static blocks
                    }

                    // --- The Search ---
                    // We take the pixel at (x, y) in PrevFrame
                    // We look for the best match in CurrentFrame within +/- radius
                    
                    // Simplified Block Matching: We track a single representative pixel or a tiny 3x3 average
                    // True block matching uses SAD (Sum of Absolute Differences) over a block (e.g. 8x8)
                    // For JS performance, we will do SAD on a sparse 4x4 block
                    
                    let minSAD = Infinity;
                    let bestDx = 0;
                    let bestDy = 0;
                    
                    // Defines the block size we are trying to match
                    const blockSize = 4; 
                    
                    // Search Loop (Spiral or simple box)
                    for (let dy = -radius; dy <= radius; dy += step) {
                        for (let dx = -radius; dx <= radius; dx += step) {
                            
                            let currentSAD = 0;
                            
                            // Calculate SAD for this displacement
                            // We compare a few points inside the block to verify match
                            for(let by = 0; by < blockSize; by+=2) {
                                for(let bx = 0; bx < blockSize; bx+=2) {
                                    
                                    const pX = x + bx;
                                    const pY = y + by;
                                    
                                    const cX = pX + dx;
                                    const cY = pY + dy;
                                    
                                    // Boundary check
                                    if(cX < 0 || cX >= w || cY < 0 || cY >= h) {
                                        currentSAD += 1000; // Penalize out of bounds
                                        continue;
                                    }
                                    
                                    const idxPrev = (pY * w + pX) * 4;
                                    const idxCurr = (cY * w + cX) * 4;
                                    
                                    // Compare luminance (green channel is a good approx for speed)
                                    const diff = Math.abs(imgDataPrev[idxPrev+1] - imgDataCurrent[idxCurr+1]);
                                    currentSAD += diff;
                                }
                            }
                            
                            if (currentSAD < minSAD) {
                                minSAD = currentSAD;
                                bestDx = dx;
                                bestDy = dy;
                            }
                        }
                    }
                    
                    // Determine if the best match is actually a match (avoid false positives on flat textures)
                    // And ensure there was movement
                    if (minSAD < (blockSize*blockSize * 20) && (bestDx !== 0 || bestDy !== 0)) {
                        vectors++;
                        drawVector(x, y, bestDx, bestDy);
                    }
                }
            }

            // Update Previous Frame with Current
            prevCtx.drawImage(video, 0, 0);
            
            vectorCountDisplay.innerText = vectors;
        }

        function drawVector(x, y, dx, dy) {
            const mode = config.mode;
            
            // Amp up the vector slightly for visibility
            const scale = 1.5; 
            const endX = x + dx * scale;
            const endY = y + dy * scale;

            ctx.beginPath();
            
            if (mode === 'dots') {
                ctx.rect(endX-1, endY-1, 2, 2);
            } 
            else if (mode === 'block') {
                // Draws a box at the new predicted location
                ctx.strokeRect(endX - config.gridSize/4, endY - config.gridSize/4, config.gridSize/2, config.gridSize/2);
            }
            else {
                // Lines or Arrows
                ctx.moveTo(x, y);
                ctx.lineTo(endX, endY);
                
                if (mode === 'arrows') {
                    // Simple arrow head
                    const angle = Math.atan2(dy, dx);
                    const head = 3;
                    ctx.lineTo(endX - head * Math.cos(angle - Math.PI / 6), endY - head * Math.sin(angle - Math.PI / 6));
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(endX - head * Math.cos(angle + Math.PI / 6), endY - head * Math.sin(angle + Math.PI / 6));
                }
            }
            ctx.stroke();
        }
    </script>
</body>
</html>
